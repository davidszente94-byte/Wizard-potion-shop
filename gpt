int lastGoldGain = 0;
int lastQuestGain = 0;
bool showGoldAnimation = false;





void sellPotion(int slot) {
  final data = brewSlots[slot];
  if (data == null) return;

  List<int> ids = List<int>.from(data["plants"]);
  int baseReward = calculatePotionReward(ids);

  if (doubleGoldCharges > 0) {
    baseReward *= 2;
    doubleGoldCharges--;
  }

  ids.sort();
  String key = ids.join("_");

  int questReward = checkDailyQuests(key);

  gold += baseReward + questReward;

  lastGoldGain = baseReward;
  lastQuestGain = questReward;
  showGoldAnimation = true;

  brewSlots[slot] = null;
  save();
  notifyListeners();

  Future.delayed(const Duration(milliseconds: 1000), () {
    showGoldAnimation = false;
    notifyListeners();
  });
}






if (game.showGoldAnimation)
  Positioned(
    top: 60,
    left: 20,
    child: TweenAnimationBuilder(
      tween: Tween<double>(begin: 0, end: -40),
      duration: const Duration(milliseconds: 900),
      builder: (_, double value, child) {
        return Transform.translate(
          offset: Offset(0, value),
          child: Opacity(
            opacity: 1 - (value.abs() / 40),
            child: child,
          ),
        );
      },
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              const Icon(Icons.monetization_on,
                  color: Colors.amber, size: 22),
              Text(
                "+${game.lastGoldGain}",
                style: const TextStyle(
                  color: Colors.amber,
                  fontWeight: FontWeight.bold,
                  fontSize: 18,
                ),
              ),
            ],
          ),
          if (game.lastQuestGain > 0)
            Row(
              children: [
                const Icon(Icons.star,
                    color: Colors.lightBlue, size: 18),
                Text(
                  "+${game.lastQuestGain} quest",
                  style: const TextStyle(
                    color: Colors.lightBlue,
                    fontWeight: FontWeight.bold,
                    fontSize: 14,
                  ),
                ),
              ],
            ),
        ],
      ),
    ),
  ),



















void generateDailyQuestsIfNeeded() {
  String today = DateTime.now().toIso8601String().substring(0, 10);

  if (lastQuestDay == today && dailyQuests.isNotEmpty) {
    return; // már vannak questek mára
  }

  lastQuestDay = today;
  dailyQuests.clear();

  final common = ["0_0_0", "1_1_1", "2_2_2"].toList();
  final rare = ["3_3_3", "4_4_4", "5_5_5"].toList();

  common.shuffle();
  rare.shuffle();

  dailyQuests.add(DailyQuest(
    recipeKey: common[0],
    reward: 10,
  ));
  dailyQuests.add(DailyQuest(
    recipeKey: common[1],
    reward: 12,
  ));
  dailyQuests.add(DailyQuest(
    recipeKey: rare[0],
    reward: 30,
  ));

  save();
  notifyListeners();
}







Future<void> save() async {
  await prefs.setInt("gold", gold);
  await prefs.setInt("unlockedSlots", unlockedSlots);




















class DailyQuest {
  String recipeKey;
  int reward;
  bool done;

  DailyQuest({
    required this.recipeKey,
    required this.reward,
    this.done = false,
  });

  Map<String, dynamic> toJson() {
    return {
      "key": recipeKey,
      "reward": reward,
      "done": done,
    };
  }

  factory DailyQuest.fromJson(Map<String, dynamic> json) {
    return DailyQuest(
      recipeKey: json["key"],
      reward: json["reward"],
      done: json["done"],
    );
  }
}


// daily quests mentése
List<String> questJson = dailyQuests
    .map((q) => jsonEncode(q.toJson()))
    .toList();

await prefs.setStringList("dailyQuests", questJson);


lastQuestDay = prefs.getString("lastQuestDay") ?? "";

// daily questek betöltése
List<String>? questJson = prefs.getStringList("dailyQuests");
if (questJson != null) {
  dailyQuests = questJson
      .map((q) => DailyQuest.fromJson(jsonDecode(q)))
      .toList();
}




void generateDailyQuestsIfNeeded() {
  String today = DateTime.now().toIso8601String().substring(0, 10);

  if (lastQuestDay == today && dailyQuests.isNotEmpty) {
    return; // már vannak questek mára
  }

  lastQuestDay = today;
  dailyQuests.clear();

  final common = ["0_0_0", "1_1_1", "2_2_2"];
  final rare = ["3_3_3", "4_4_4", "5_5_5"];

  common.shuffle();
  rare.shuffle();

  dailyQuests.add(DailyQuest(
    recipeKey: common[0],
    reward: 10,
  ));
  dailyQuests.add(DailyQuest(
    recipeKey: common[1],
    reward: 12,
  ));
  dailyQuests.add(DailyQuest(
    recipeKey: rare[0],
    reward: 30,
  ));

  save();
}












int questReward = checkDailyQuests(key);

int total = reward + questReward;

gold += total;
lastGoldGain = total;


int checkDailyQuests(String key) {
  int reward = 0;

  for (var q in dailyQuests) {
    if (!q.done && q.recipeKey == key) {
      q.done = true;
      reward += q.reward;
    }
  }

  if (dailyQuests.isNotEmpty &&
      dailyQuests.every((q) => q.done)) {
    giveDailyChest();
  }

  return reward;
}



void sellPotion(int slot) {
  final data = brewSlots[slot];
  if (data == null) return;

  List<int> ids = List<int>.from(data["plants"]);
  int reward = calculatePotionReward(ids);

  if (doubleGoldCharges > 0) {
    reward *= 2;
    doubleGoldCharges--;
  }

  ids.sort();
  String key = ids.join("_");

  int questReward = checkDailyQuests(key);
  int total = reward + questReward;

  gold += total;
  lastGoldGain = total;
  showGoldAnimation = true;

  brewSlots[slot] = null;
  save();
  notifyListeners();

  Future.delayed(const Duration(milliseconds: 800), () {
    showGoldAnimation = false;
    notifyListeners();
  });
}



lastQuestDay = prefs.getString("lastQuestDay") ?? "";

generateDailyQuestsIfNeeded();
notifyListeners();









final List<Plant> plants = [
  // COMMON (Active Play: 1m to 15m)
  Plant(0, "Sunleaf", 5, Duration(minutes: 1)),
  Plant(1, "Moonpetal", 20, Duration(minutes: 5)),
  Plant(2, "Starroot", 50, Duration(minutes: 15)),

  // RARE (Occasional Check-ins: 1h to 8h)
  Plant(3, "Frost Fern", 200, Duration(hours: 1)),
  Plant(4, "Mint Crystal", 750, Duration(hours: 4)),
  Plant(5, "Ember Blossom", 2000, Duration(hours: 8)),

  // LEGENDARY (The Daily Hook: 24h)
  Plant(6, "Phoenix Herb", 10000, Duration(hours: 24)),
];


Duration brewTime(List<int> ids) {
  int totalGrowSeconds = 0;
  for (var id in ids) {
    totalGrowSeconds += plants[id].growTime.inSeconds;
  }

  // Brewing takes half the time it took to grow the ingredients
  double baseSeconds = totalGrowSeconds * 0.5;
  
  // Minimum brew time of 30 seconds so it's never "instant" for free
  if (baseSeconds < 30) baseSeconds = 30;

  int adjustedSeconds = (baseSeconds / brewSpeed).round();
  return Duration(seconds: adjustedSeconds);
}


int calculatePotionReward(List<int> ids) {
  int totalCost = 0;
  for (var id in ids) {
    totalCost += plants[id].cost;
  }

  // Determine multiplier based on recipe rarity
  final rarity = getRarity(ids);
  double multiplier = 1.5; // Common: 50% profit
  if (rarity == Rarity.rare) multiplier = 2.5; // Rare: 150% profit
  if (rarity == Rarity.epic) multiplier = 5.0; // Legendary: 400% profit

  double reward = totalCost * multiplier;

  // First Discovery Bonus: Double the gold!
  ids.sort();
  String key = ids.join("_");
  if (!discovered.contains(key)) {
    reward *= 2;
  }

  return reward.round();
}


int nextGardenSlotCost() {
  if (unlockedSlots >= maxGardenSlots) return -1;

  // Exponential scaling: 500, 2500, 12500, 62500...
  // This ensures players can't buy all slots in the first week.
  switch (unlockedSlots) {
    case 3: return 500;
    case 4: return 2500;
    case 5: return 10000;
    case 6: return 25000;
    case 7: return 75000;
    case 8: return 200000;
    case 9: return 500000;
    default: return 1000000;
  }
}












final List<Plant> plants = [
  // COMMON (0–2)
  Plant(0, "Sunleaf", 2, Duration(seconds: 10)),
  Plant(1, "Moonpetal", 3, Duration(seconds: 15)),
  Plant(2, "Starroot", 4, Duration(seconds: 20)),

  // RARE (3–5)
  Plant(3, "Frost Fern", 8, Duration(minutes: 1)),
  Plant(4, "Mint Crystal", 10, Duration(minutes: 2)),
  Plant(5, "Ember Blossom", 12, Duration(minutes: 3)),

  // LEGENDARY (6)
  Plant(6, "Phoenix Herb", 25, Duration(minutes: 6)),
];


void sellPotion(int slot) {
  final data = brewSlots[slot];
  if (data == null) return;

  List<int> ids = List<int>.from(data["plants"]);
  int reward = calculatePotionReward(ids);

  if (doubleGoldCharges > 0) {
    reward *= 2;
    doubleGoldCharges--;
  }

  ids.sort();
  String key = ids.join("_");
  checkDailyQuests(key);

  gold += reward;
  lastGoldGain = reward;
  showGoldAnimation = true;

  brewSlots[slot] = null;
  save();
  notifyListeners();

  Future.delayed(const Duration(milliseconds: 800), () {
    showGoldAnimation = false;
    notifyListeners();
  });
}



void checkDailyQuests(String key) {
  for (var q in dailyQuests) {
    if (!q.done && q.recipeKey == key) {
      q.done = true;
      gold += q.reward;
    }
  }

  if (dailyQuests.isNotEmpty &&
      dailyQuests.every((q) => q.done)) {
    giveDailyChest();
  }
}




void giveDailyChest() {
  final r = Random().nextDouble();

  if (r < 0.5) {
    storage[3] += 2;
  } else if (r < 0.8) {
    instantBrewTokens++;
  } else if (r < 0.95) {
    storage[6] += 1;
  } else {
    doubleGoldCharges += 3;
  }
}

void checkBrew() {


unlockedSlots = prefs.getInt("unlockedSlots") ?? 3;

lastQuestDay = prefs.getString("lastQuestDay") ?? "";


await prefs.setString("lastQuestDay", lastQuestDay);










void useInstantBrew(int slot) {
  final data = brewSlots[slot];
  if (data == null) return;
  if (instantBrewTokens <= 0) return;

  data["done"] = true;
  instantBrewTokens--;

  save();
  notifyListeners();
}


int doubleGoldCharges = 0;


void sellPotion(int slot) {
  final data = brewSlots[slot];
  if (data == null) return;

  List<int> ids = List<int>.from(data["plants"]);
  int reward = calculatePotionReward(ids);

  if (doubleGoldCharges > 0) {
    reward *= 2;
    doubleGoldCharges--;
  }

  gold += reward;
  lastGoldGain = reward;
  showGoldAnimation = true;

  brewSlots[slot] = null;
  save();
  notifyListeners();

  Future.delayed(const Duration(milliseconds: 800), () {
    showGoldAnimation = false;
    notifyListeners();
  });
}



class DailyQuest {
  String recipeKey;
  int reward;
  bool done;

  DailyQuest({
    required this.recipeKey,
    required this.reward,
    this.done = false,
  });
}


List<DailyQuest> dailyQuests = [];
String lastQuestDay = "";



void generateDailyQuestsIfNeeded() {
  String today = DateTime.now().toIso8601String().substring(0, 10);

  if (lastQuestDay == today) return;

  lastQuestDay = today;
  dailyQuests.clear();

  // 2 common + 1 rare
  final common = ["0_0_0", "1_1_1", "2_2_2"];
  final rare = ["3_3_3", "4_4_4", "5_5_5"];

  common.shuffle();
  rare.shuffle();

  dailyQuests.add(DailyQuest(
    recipeKey: common[0],
    reward: 10,
  ));
  dailyQuests.add(DailyQuest(
    recipeKey: common[1],
    reward: 12,
  ));
  dailyQuests.add(DailyQuest(
    recipeKey: rare[0],
    reward: 30,
  ));
}



void checkDailyQuests(String key) {
  for (var q in dailyQuests) {
    if (!q.done && q.recipeKey == key) {
      q.done = true;
      gold += q.reward;
    }
  }

  // ha mind kész → chest
  if (dailyQuests.every((q) => q.done)) {
    giveDailyChest();
  }
}



void giveDailyChest() {
  final r = Random().nextDouble();

  if (r < 0.5) {
    storage[3] += 2; // rare plant példa
  } else if (r < 0.8) {
    instantBrewTokens++;
  } else if (r < 0.95) {
    storage[6] += 1; // legendary plant
  } else {
    doubleGoldCharges += 3;
  }
}






class Recipe {
  final List<int> ids;
  final String name;
  final Rarity rarity;

  const Recipe(this.ids, this.name, this.rarity);

  String get key {
    final sorted = List<int>.from(ids)..sort();
    return sorted.join("_");
  }
}




const List<Recipe> allRecipes = [
  // COMMON
  Recipe([0, 0, 0], "Solar Tonic", Rarity.common),
  Recipe([1, 1, 1], "Lunar Draught", Rarity.common),
  Recipe([2, 2, 2], "Stellar Essence", Rarity.common),
  Recipe([0, 1, 2], "Balanced Brew", Rarity.common),
  Recipe([0, 0, 1], "Dawn Mixture", Rarity.common),

  // RARE
  Recipe([0, 0, 3], "Glow Tonic", Rarity.rare),
  Recipe([1, 1, 4], "Moonmint Infusion", Rarity.rare),
  Recipe([2, 2, 5], "Ember Essence", Rarity.rare),
  Recipe([3, 3, 3], "Fern Extract", Rarity.rare),
  Recipe([4, 4, 4], "Mint Concentrate", Rarity.rare),
  Recipe([5, 5, 5], "Ember Core", Rarity.rare),
  Recipe([3, 4, 5], "Elemental Mix", Rarity.rare),

  // LEGENDARY
  Recipe([6, 6, 6], "Elixir of Rebirth", Rarity.epic),
  Recipe([5, 6, 6], "Phoenix Blood", Rarity.epic),
  Recipe([4, 6, 6], "Celestial Flame", Rarity.epic),
];




String getPotionName(List<int> ids) {
  final sorted = List<int>.from(ids)..sort();
  final key = sorted.join("_");

  for (final recipe in allRecipes) {
    if (recipe.key == key) {
      return recipe.name;
    }
  }

  return "Mystic Elixir";
}






Rarity getRarity(List<int> ids) {
  final sorted = List<int>.from(ids)..sort();
  final key = sorted.join("_");

  for (final recipe in allRecipes) {
    if (recipe.key == key) {
      return recipe.rarity;
    }
  }

  return Rarity.common;
}



@override
Widget build(BuildContext context) {
  return Scaffold(
    appBar: AppBar(title: const Text("Potion Book")),
    body: ListView(
      children: allRecipes.map((recipe) {
        final discovered = game.discovered.contains(recipe.key);

        return Card(
          margin: const EdgeInsets.symmetric(
              horizontal: 12, vertical: 6),
          child: ListTile(
            leading: Icon(
              Icons.local_drink,
              color: discovered
                  ? game.rarityColor(recipe.rarity)
                  : Colors.grey,
              size: 32,
            ),
            title: Text(
              discovered ? recipe.name : "????",
              style: const TextStyle(
                fontWeight: FontWeight.bold,
              ),
            ),
            subtitle: Text(
              discovered
                  ? "Recipe: ${recipe.ids.join(" + ")}"
                  : "Recipe: ???",
            ),
          ),
        );
      }).toList(),
    ),
  );
}















final List<Plant> plants = [
  // COMMON (0–2)
  Plant("Sunleaf", 5, Colors.green),
  Plant("Moonpetal", 6, Colors.lightBlue),
  Plant("Starroot", 7, Colors.yellow),

  // RARE (3–5)
  Plant("Frost Fern", 15, Colors.cyan),
  Plant("Mint Crystal", 18, Colors.teal),
  Plant("Ember Blossom", 22, Colors.deepOrange),

  // LEGENDARY (6)
  Plant("Phoenix Herb", 100, Colors.redAccent),
];




String getPotionName(List<int> ids) {
  ids = List.from(ids)..sort();
  final key = ids.join("_");

  const names = {
    // COMMON – only plants 0–2
    "0_0_0": "Solar Tonic",
    "1_1_1": "Lunar Draught",
    "2_2_2": "Stellar Essence",
    "0_1_2": "Balanced Brew",
    "0_0_1": "Dawn Mixture",

    // RARE – plants 3–5 involved
    "0_0_3": "Glow Tonic",
    "1_1_4": "Moonmint Infusion",
    "2_2_5": "Ember Essence",
    "0_3_4": "Crystal Blend",
    "1_4_5": "Frost Ember Draught",
    "2_3_5": "Flare Potion",
    "3_3_3": "Fern Extract",
    "4_4_4": "Mint Concentrate",
    "5_5_5": "Ember Core",
    "3_4_5": "Elemental Mix",

    // LEGENDARY – phoenix plant
    "6_6_6": "Elixir of Rebirth",
    "5_6_6": "Phoenix Blood",
    "4_6_6": "Celestial Flame",
  };

  return names[key] ?? "Mystic Elixir";
}





Rarity getRarity(List<int> ids) {
  ids = List.from(ids)..sort();
  final key = ids.join("_");

  const commonRecipes = {
    "0_0_0",
    "1_1_1",
    "2_2_2",
    "0_1_2",
    "0_0_1",
  };

  const rareRecipes = {
    "0_0_3",
    "1_1_4",
    "2_2_5",
    "0_3_4",
    "1_4_5",
    "2_3_5",
    "3_3_3",
    "4_4_4",
    "5_5_5",
    "3_4_5",
  };

  const legendaryRecipes = {
    "6_6_6",
    "5_6_6",
    "4_6_6",
  };

  if (legendaryRecipes.contains(key)) {
    return Rarity.epic;
  }
  if (rareRecipes.contains(key)) {
    return Rarity.rare;
  }
  if (commonRecipes.contains(key)) {
    return Rarity.common;
  }

  return Rarity.common;
}







String getPotionName(List<int> ids) {
  ids = List.from(ids)..sort();
  final key = ids.join("_");

  const names = {
    // COMMON – free plants only (5 recipes)
    "0_0_0": "Solar Tonic",
    "1_1_1": "Lunar Draught",
    "2_2_2": "Stellar Essence",
    "0_1_2": "Balanced Brew",
    "0_0_1": "Dawn Mixture",

    // RARE – at least one paid plant (10 recipes)
    "0_0_3": "Glow Tonic",
    "1_1_3": "Moonlit Infusion",
    "2_2_4": "Frost Essence",
    "0_3_4": "Crystal Blend",
    "1_4_5": "Ember Draught",
    "2_3_5": "Flare Potion",
    "3_3_3": "Fern Extract",
    "4_4_4": "Mint Concentrate",
    "5_5_5": "Ember Core",
    "3_4_5": "Elemental Mix",

    // LEGENDARY – very expensive
    "9_9_9": "Elixir of Rebirth",
    "8_9_9": "Phoenix Blood",
    "7_9_9": "Celestial Flame",
  };

  return names[key] ?? "Mystic Elixir";
}




Rarity getRarity(List<int> ids) {
  ids = List.from(ids)..sort();
  final key = ids.join("_");

  const commonRecipes = {
    "0_0_0",
    "1_1_1",
    "2_2_2",
    "0_1_2",
    "0_0_1",
  };

  const rareRecipes = {
    "0_0_3",
    "1_1_3",
    "2_2_4",
    "0_3_4",
    "1_4_5",
    "2_3_5",
    "3_3_3",
    "4_4_4",
    "5_5_5",
    "3_4_5",
  };

  const legendaryRecipes = {
    "9_9_9",
    "8_9_9",
    "7_9_9",
  };

  if (legendaryRecipes.contains(key)) {
    return Rarity.epic;
  }
  if (rareRecipes.contains(key)) {
    return Rarity.rare;
  }
  if (commonRecipes.contains(key)) {
    return Rarity.common;
  }

  return Rarity.common;
}








children: List.generate(game.garden.length, (i) {
        if (i >= game.unlockedSlots) {
          int cost = game.nextGardenSlotCost();
      
          return SizedBox(
            width: 100,
            height: 100,
            child: ElevatedButton(
              onPressed: game.gold >= cost
                  ? game.unlockGardenSlot
                  : null,
              child: Text(
                cost < 0
                    ? "MAX"
                    : "Unlock\n${cost}g",
                textAlign: TextAlign.center,
              ),
            ),
          );
        }
      
        final slot = game.garden[i];
      
        if (slot == null) {
          return SizedBox(
            width: 100,
            height: 100,
            child: ElevatedButton(
              onPressed: () {
                showDialog(
                  context: context,
                  builder: (_) => plantDialog(context, i),
                );
              },
              child: const Text("Plant"),
            ),
          );
        } else {
          int id = slot["plant"];
          int start = slot["start"];
          final p = plants[id];
      
          final elapsed = DateTime.now().difference(
              DateTime.fromMillisecondsSinceEpoch(start));
      
          double progress =
              elapsed.inMilliseconds /
                  p.growTime.inMilliseconds;
      
          if (progress >= 1) {
            return SizedBox(
              width: 100,
              height: 100,
              child: ElevatedButton(
                onPressed: () => game.harvest(i),
                child: Text("Harvest\n${p.name}",
                    textAlign: TextAlign.center),
              ),
            );
          }
      
          return SizedBox(
            width: 100,
            height: 100,
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Text(p.name, textAlign: TextAlign.center),
                const SizedBox(height: 6),
                LinearProgressIndicator(value: progress),
              ],
            ),
          );
        }
      }),








return Wrap(
    spacing: 10,
      runSpacing: 10,
        children: ...
        );
)
