kerülne. Emellett a 0ás seedet tilos itt választani, hiszen az alapból ingyenes, ez miatt nem megy a játékos soha csődbe. Válogasson a seed package random az  1,2,3 közül, de nem adhat 4es celestial seedet. az esélyek, hogy melyik hány%-al jön ki belőle definiáld te ésszerűen, és ennek értelmében adj a package-nek árat is (200 az túl olcsó).

onPressed: () {
  final beforeLevel = game.level;

  game.sellPotion(i);

  if (game.level > beforeLevel) {
    showDialog(
      context: context,
      builder: (_) => AlertDialog(
        title: const Text("Level Up!"),
        content: Text(
          "Congratulations! You reached level ${game.level}!",
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text("OK"),
          ),
        ],
      ),
    );
  }
},













void checkBrew() {
  bool changed = false;

  for (int i = 0; i < 3; i++) {
    final slot = brewSlots[i];
    if (slot == null) continue;
    if (slot["done"] == true) continue;

    int start = slot["start"];
    int total = slot["time"];

    int elapsed = DateTime
        .now()
        .difference(
        DateTime.fromMillisecondsSinceEpoch(start))
        .inSeconds;

    if (elapsed >= total) {
      List<int> ids =
          List<int>.from(slot["plants"]);
      ids.sort();
      discovered.add(ids.join("_"));
      slot["done"] = true;
      changed = true;
    }
  }

  if (changed) {
    save();
    notifyListeners();
  }
}






storage = List.generate(
    plants.length, (i) => prefs.getInt("storage_$i") ?? 0);

seedStorage = List.generate(
    seeds.length, (i) => prefs.getInt("seeds_$i") ?? 0);




for (int i = 0; i < plants.length; i++) {
  await prefs.setInt("storage_$i", storage[i]);
}

for (int i = 0; i < seeds.length; i++) {
  await prefs.setInt("seeds_$i", seedStorage[i]);
}







bool checkLevelUp() {
  bool leveled = false;

  while (true) {
    int needed = 100 * level * level;
    if (xp < needed) break;
    xp -= needed;
    level++;
    leveled = true;
  }

  if (leveled) notifyListeners();
  return leveled;
}





Timer? timer;

@override
void initState() {
  super.initState();
  game.load().then((_) {
    setState(() => loaded = true);
    timer = Timer.periodic(
        const Duration(seconds: 1), (_) => game.checkBrew());
  });
}

@override
void dispose() {
  timer?.cancel();
  super.dispose();
}






void checkBrew() {
  bool changed = false;

  for (int i = 0; i < 3; i++) {
    final slot = brewSlots[i];
    if (slot == null) continue;
    if (slot["done"] == true) continue;

    int start = slot["start"];
    int total = slot["time"];

    int elapsed = DateTime.now()
        .difference(DateTime.fromMillisecondsSinceEpoch(start))
        .inSeconds;

    if (elapsed >= total) {
      List<int> ids = List<int>.from(slot["plants"]);
      ids.sort();
      discovered.add(ids.join("_"));
      slot["done"] = true;
      changed = true;
    }
  }

  if (changed) {
    save();
    notifyListeners();
  }
}










List<int> storage =
    List.generate(plants.length, (_) => 0);
List<int> seedStorage =
    List.generate(seeds.length, (_) => 0);




g.instantBrewTokens += 3;



brewSlots[slot] = null;
save();
notifyListeners();

if (leveled) {
  showGoldAnimation = false;
}

Future.delayed(const Duration(milliseconds: 1000), () {
  showGoldAnimation = false;
  notifyListeners();
});








onPressed: () {
  final beforeLevel = game.level;
  final plantId = game.harvest(i);

  if (plantId != null) {
    final plant = plants[plantId];

    showDialog(
      context: context,
      builder: (_) => AlertDialog(
        title: const Text("Harvest Complete"),
        content: Text(
          '1x ${plant.name} is added to your inventory',
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text("OK"),
          )
        ],
      ),
    );

    if (game.level > beforeLevel) {
      showDialog(
        context: context,
        builder: (_) => AlertDialog(
          title: const Text("Level Up!"),
          content: Text(
            "Congratulations! You reached level ${game.level}!",
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.pop(context),
              child: const Text("OK"),
            ),
          ],
        ),
      );
    }
  }
},







int xpGain = calculatePotionXp(ids);
gainXP(xpGain);






final rarity = getRarity(ids);
final xp = getPotionXp(rarity);
gainXP(xp);





int? harvest(int slot) {
  final data = garden[slot];
  if (data == null) return null;

  int seedId = data["seedId"];
  int start = data["start"];

  final seed = seeds[seedId];

  final elapsed = DateTime.now().difference(
      DateTime.fromMillisecondsSinceEpoch(start));

  int growTime = seed.growTime.inSeconds;

  if (elapsed.inSeconds < growTime) return null;

  double roll = Random().nextDouble();
  double sum = 0;
  int resultPlant = seed.results.first.plantId;

  for (var r in seed.results) {
    sum += r.chance;
    if (roll <= sum) {
      resultPlant = r.plantId;
      break;
    }
  }

  storage[resultPlant]++;
  garden[slot] = null;

  // XP itt kerül kiosztásra
  gainXP(getPlantXp(resultPlant));

  save();
  notifyListeners();

  return resultPlant;
}






onPressed: () {
  final plantId = game.harvest(i);
  if (plantId != null) {
    final plant = plants[plantId];

    showDialog(
      context: context,
      builder: (_) => AlertDialog(
        title: const Text("Harvest Complete"),
        content: Text(
          '1x ${plant.name} is added to your inventory',
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text("OK"),
          )
        ],
      ),
    );
  }
},








int xpGain = calculatePotionXp(ids);
bool leveled = gainXP(xpGain);

















double roll = Random().nextDouble();
double sum = 0;
int resultPlant = seed.results.first.plantId;

for (var r in seed.results) {
  sum += r.chance;
  if (roll <= sum) {
    resultPlant = r.plantId;
    break;
  }
}

// XP a konkrét növény után
bool leveled = gainXP(getPlantXp(resultPlant));




final plantId = game.harvest(i);
if (plantId != null) {
  final plant = plants[plantId];

  bool leveled = game.gainXP(game.getPlantXp(plantId));

  showDialog(
    context: context,
    builder: (_) => AlertDialog(
      title: const Text("Harvest Complete"),
      content: Text(
        '1x ${plant.name} is added to your inventory',
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.pop(context),
          child: const Text("OK"),
        )
      ],
    ),
  );

  if (leveled) {
    showDialog(
      context: context,
      builder: (_) => AlertDialog(
        title: const Text("Level Up!"),
        content: Text(
          "Congratulations! You reached level ${game.level}!",
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text("OK"),
          ),
        ],
      ),
    );
  }
}







title: Column(
  crossAxisAlignment: CrossAxisAlignment.start,
  children: [
    Text(
      "Lv ${game.level}   Gold: ${game.gold}   Crystals: ${game.crystals}",
    ),
    const SizedBox(height: 4),
    SizedBox(
      width: 180,
      child: LinearProgressIndicator(
        value: game.xpProgress(),
        minHeight: 6,
        backgroundColor: Colors.grey.shade800,
        valueColor: const AlwaysStoppedAnimation<Color>(Colors.blue),
      ),
    ),
    Text(
      "Instant Brew Tokens: ${game.instantBrewTokens}",
      style: const TextStyle(fontSize: 12),
    ),
  ],
),












double xpProgress() {
  int needed = 100 * level * level;
  return (xp / needed).clamp(0.0, 1.0);
}






bool checkLevelUp() {
  int needed = 100 * level * level;
  if (xp >= needed) {
    xp -= needed;
    level++;
    notifyListeners();
    return true;
  }
  return false;
}






bool gainXP(int amount) {
  xp += amount;
  return checkLevelUp();
}




bool leveled = game.gainXP(plantXp);

if (leveled) {
  showDialog(
    context: context,
    builder: (_) => AlertDialog(
      title: const Text("Level Up!"),
      content: Text(
        "Congratulations! You reached level ${game.level}!",
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.pop(context),
          child: const Text("OK"),
        ),
      ],
    ),
  );
}







Column(
  crossAxisAlignment: CrossAxisAlignment.start,
  children: [
    Text(
      "Lvl ${game.level}",
      style: const TextStyle(
        fontWeight: FontWeight.bold,
        fontSize: 16,
      ),
    ),
    const SizedBox(height: 4),
    SizedBox(
      width: 120,
      child: LinearProgressIndicator(
        value: game.xpProgress(),
        minHeight: 6,
        backgroundColor: Colors.grey.shade800,
        valueColor:
            const AlwaysStoppedAnimation<Color>(Colors.blue),
      ),
    ),
  ],
),












int getPlantXp(int plantId) {
  final plant = plants[plantId];
  return (plant.cost / 2).round();
}





int getPotionXp(Rarity rarity) {
  switch (rarity) {
    case Rarity.common:
      return 80;
    case Rarity.rare:
      return 250;
    case Rarity.epic:
      return 900;
  }
}




final xp = getPlantXp(plantId);
addXp(xp);



final rarity = getRarity(ids);
final xp = getPotionXp(rarity);
addXp(xp);










int level = 1;
int xp = 0;




int xpToNextLevel() {
  return 50 + (level - 1) * 25;
}


void addXp(int amount) {
  xp += amount;

  while (xp >= xpToNextLevel()) {
    xp -= xpToNextLevel();
    level++;
    onLevelUp();
  }

  save();
  notifyListeners();
}




void onLevelUp() {
  crystals += 5; // egyszerű jutalom
}



int calculatePotionXp(List<int> ids) {
  final rarity = getRarity(ids);

  switch (rarity) {
    case Rarity.common:
      return 5;
    case Rarity.rare:
      return 15;
    case Rarity.epic:
      return 40;
  }
}





int xpGain = calculatePotionXp(ids);
addXp(xpGain);




gold += baseReward + questReward;

int xpGain = calculatePotionXp(ids);
addXp(xpGain);

lastGoldGain = baseReward;




level = prefs.getInt("level") ?? 1;
xp = prefs.getInt("xp") ?? 0;





await prefs.setInt("level", level);
await prefs.setInt("xp", xp);





title: Text("Gold: ${game.gold}   Crystals: ${game.crystals}"),





title: Column(
  crossAxisAlignment: CrossAxisAlignment.start,
  children: [
    Text("Lv ${game.level}   Gold: ${game.gold}   Crystals: ${game.crystals}"),
    Text(
      "XP: ${game.xp}/${game.xpToNextLevel()}",
      style: const TextStyle(fontSize: 12),
    ),
  ],
),





instantBrewTokens += 1;











actions: [
  TextButton(
    onPressed: () => setState(() => screen = 0),
    child: const Text("Brew", style: TextStyle(color: Colors.white)),
  ),
  TextButton(
    onPressed: () => setState(() => screen = 1),
    child: const Text("Garden", style: TextStyle(color: Colors.white)),
  ),
  TextButton(
    onPressed: () => setState(() => screen = 2),
    child: const Text("Shop", style: TextStyle(color: Colors.white)),
  ),
  IconButton(
    icon: const Icon(Icons.book),
    onPressed: () {
      Navigator.push(
        context,
        MaterialPageRoute(
          builder: (_) => RecipeBookScreen(game),
        ),
      );
    },
  ),
],






body: screen == 0
    ? PotionScreen(game)
    : screen == 1
        ? GardenScreen(game)
        : ShopScreen(game),





















enum ShopCurrency { gold, crystal }

class ShopItem {
  final String name;
  final ShopCurrency currency;
  final int price;
  final void Function(GameState) onBuy;

  const ShopItem({
    required this.name,
    required this.currency,
    required this.price,
    required this.onBuy,
  });
}


int lastGoldGain = 0;
int lastQuestGain = 0;
bool showGoldAnimation = false;



List<ShopItem> shopItems = [];

initShop();


void initShop() {
  shopItems = [
    // Gold items
    ShopItem(
      name: "Wild Seed x5",
      currency: ShopCurrency.gold,
      price: 50,
      onBuy: (g) {
        g.seedStorage[0] += 5;
      },
    ),
    ShopItem(
      name: "Instant Brew",
      currency: ShopCurrency.gold,
      price: 100,
      onBuy: (g) {
        g.instantBrewTokens++;
      },
    ),

    // Crystal items
    ShopItem(
      name: "Rare Potion",
      currency: ShopCurrency.crystal,
      price: 25,
      onBuy: (g) {
        g.doubleGoldCharges += 3;
      },
    ),
    ShopItem(
      name: "Epic Potion",
      currency: ShopCurrency.crystal,
      price: 75,
      onBuy: (g) {
        g.doubleGoldCharges += 10;
      },
    ),
  ];
}




void buyShopItem(ShopItem item) {
  if (item.currency == ShopCurrency.gold) {
    if (gold < item.price) return;
    gold -= item.price;
  } else {
    if (crystals < item.price) return;
    crystals -= item.price;
  }

  item.onBuy(this);

  save();
  notifyListeners();
}






class ShopScreen extends StatelessWidget {
  final GameState game;

  const ShopScreen(this.game, {super.key});

  @override
  Widget build(BuildContext context) {
    return ListView(
      children: game.shopItems.map((item) {
        final isGold = item.currency == ShopCurrency.gold;

        return ListTile(
          title: Text(item.name),
          subtitle: Text(
            "${item.price} ${isGold ? "Gold" : "Crystals"}",
          ),
          trailing: ElevatedButton(
            onPressed: () => game.buyShopItem(item),
            child: const Text("BUY"),
          ),
        );
      }).toList(),
    );
  }
}







TextButton(
  onPressed: () => setState(() => screen = 0),
  child: const Text("Brew"),
),
TextButton(
  onPressed: () => setState(() => screen = 1),
  child: const Text("Garden"),
),
TextButton(
  onPressed: () => setState(() => screen = 2),
  child: const Text("Shop"),
),





body: screen == 0
    ? PotionScreen(game)
    : screen == 1
        ? GardenScreen(game)
        : ShopScreen(game),




title: Text("Gold: ${game.gold}   Crystals: ${game.crystals}"),










void sellPotion(int slot) {
  final data = brewSlots[slot];
  if (data == null) return;

  List<int> ids = List<int>.from(data["plants"]);
  int baseReward = calculatePotionReward(ids);

  if (doubleGoldCharges > 0) {
    baseReward *= 2;
    doubleGoldCharges--;
  }

  ids.sort();
  String key = ids.join("_");

  int questReward = checkDailyQuests(key);

  gold += baseReward + questReward;

  lastGoldGain = baseReward;
  lastQuestGain = questReward;
  showGoldAnimation = true;

  brewSlots[slot] = null;
  save();
  notifyListeners();

  Future.delayed(const Duration(milliseconds: 1000), () {
    showGoldAnimation = false;
    notifyListeners();
  });
}






if (game.showGoldAnimation)
  Positioned(
    top: 60,
    left: 20,
    child: TweenAnimationBuilder(
      tween: Tween<double>(begin: 0, end: -40),
      duration: const Duration(milliseconds: 900),
      builder: (_, double value, child) {
        return Transform.translate(
          offset: Offset(0, value),
          child: Opacity(
            opacity: 1 - (value.abs() / 40),
            child: child,
          ),
        );
      },
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              const Icon(Icons.monetization_on,
                  color: Colors.amber, size: 22),
              Text(
                "+${game.lastGoldGain}",
                style: const TextStyle(
                  color: Colors.amber,
                  fontWeight: FontWeight.bold,
                  fontSize: 18,
                ),
              ),
            ],
          ),
          if (game.lastQuestGain > 0)
            Row(
              children: [
                const Icon(Icons.star,
                    color: Colors.lightBlue, size: 18),
                Text(
                  "+${game.lastQuestGain} quest",
                  style: const TextStyle(
                    color: Colors.lightBlue,
                    fontWeight: FontWeight.bold,
                    fontSize: 14,
                  ),
                ),
              ],
            ),
        ],
      ),
    ),
  ),



















void generateDailyQuestsIfNeeded() {
  String today = DateTime.now().toIso8601String().substring(0, 10);

  if (lastQuestDay == today && dailyQuests.isNotEmpty) {
    return; // már vannak questek mára
  }

  lastQuestDay = today;
  dailyQuests.clear();

  final common = ["0_0_0", "1_1_1", "2_2_2"].toList();
  final rare = ["3_3_3", "4_4_4", "5_5_5"].toList();

  common.shuffle();
  rare.shuffle();

  dailyQuests.add(DailyQuest(
    recipeKey: common[0],
    reward: 10,
  ));
  dailyQuests.add(DailyQuest(
    recipeKey: common[1],
    reward: 12,
  ));
  dailyQuests.add(DailyQuest(
    recipeKey: rare[0],
    reward: 30,
  ));

  save();
  notifyListeners();
}







Future<void> save() async {
  await prefs.setInt("gold", gold);
  await prefs.setInt("unlockedSlots", unlockedSlots);




















class DailyQuest {
  String recipeKey;
  int reward;
  bool done;

  DailyQuest({
    required this.recipeKey,
    required this.reward,
    this.done = false,
  });

  Map<String, dynamic> toJson() {
    return {
      "key": recipeKey,
      "reward": reward,
      "done": done,
    };
  }

  factory DailyQuest.fromJson(Map<String, dynamic> json) {
    return DailyQuest(
      recipeKey: json["key"],
      reward: json["reward"],
      done: json["done"],
    );
  }
}


// daily quests mentése
List<String> questJson = dailyQuests
    .map((q) => jsonEncode(q.toJson()))
    .toList();

await prefs.setStringList("dailyQuests", questJson);


lastQuestDay = prefs.getString("lastQuestDay") ?? "";

// daily questek betöltése
List<String>? questJson = prefs.getStringList("dailyQuests");
if (questJson != null) {
  dailyQuests = questJson
      .map((q) => DailyQuest.fromJson(jsonDecode(q)))
      .toList();
}




void generateDailyQuestsIfNeeded() {
  String today = DateTime.now().toIso8601String().substring(0, 10);

  if (lastQuestDay == today && dailyQuests.isNotEmpty) {
    return; // már vannak questek mára
  }

  lastQuestDay = today;
  dailyQuests.clear();

  final common = ["0_0_0", "1_1_1", "2_2_2"];
  final rare = ["3_3_3", "4_4_4", "5_5_5"];

  common.shuffle();
  rare.shuffle();

  dailyQuests.add(DailyQuest(
    recipeKey: common[0],
    reward: 10,
  ));
  dailyQuests.add(DailyQuest(
    recipeKey: common[1],
    reward: 12,
  ));
  dailyQuests.add(DailyQuest(
    recipeKey: rare[0],
    reward: 30,
  ));

  save();
}












int questReward = checkDailyQuests(key);

int total = reward + questReward;

gold += total;
lastGoldGain = total;


int checkDailyQuests(String key) {
  int reward = 0;

  for (var q in dailyQuests) {
    if (!q.done && q.recipeKey == key) {
      q.done = true;
      reward += q.reward;
    }
  }

  if (dailyQuests.isNotEmpty &&
      dailyQuests.every((q) => q.done)) {
    giveDailyChest();
  }

  return reward;
}



void sellPotion(int slot) {
  final data = brewSlots[slot];
  if (data == null) return;

  List<int> ids = List<int>.from(data["plants"]);
  int reward = calculatePotionReward(ids);

  if (doubleGoldCharges > 0) {
    reward *= 2;
    doubleGoldCharges--;
  }

  ids.sort();
  String key = ids.join("_");

  int questReward = checkDailyQuests(key);
  int total = reward + questReward;

  gold += total;
  lastGoldGain = total;
  showGoldAnimation = true;

  brewSlots[slot] = null;
  save();
  notifyListeners();

  Future.delayed(const Duration(milliseconds: 800), () {
    showGoldAnimation = false;
    notifyListeners();
  });
}



lastQuestDay = prefs.getString("lastQuestDay") ?? "";

generateDailyQuestsIfNeeded();
notifyListeners();









final List<Plant> plants = [
  // COMMON (Active Play: 1m to 15m)
  Plant(0, "Sunleaf", 5, Duration(minutes: 1)),
  Plant(1, "Moonpetal", 20, Duration(minutes: 5)),
  Plant(2, "Starroot", 50, Duration(minutes: 15)),

  // RARE (Occasional Check-ins: 1h to 8h)
  Plant(3, "Frost Fern", 200, Duration(hours: 1)),
  Plant(4, "Mint Crystal", 750, Duration(hours: 4)),
  Plant(5, "Ember Blossom", 2000, Duration(hours: 8)),

  // LEGENDARY (The Daily Hook: 24h)
  Plant(6, "Phoenix Herb", 10000, Duration(hours: 24)),
];


Duration brewTime(List<int> ids) {
  int totalGrowSeconds = 0;
  for (var id in ids) {
    totalGrowSeconds += plants[id].growTime.inSeconds;
  }

  // Brewing takes half the time it took to grow the ingredients
  double baseSeconds = totalGrowSeconds * 0.5;
  
  // Minimum brew time of 30 seconds so it's never "instant" for free
  if (baseSeconds < 30) baseSeconds = 30;

  int adjustedSeconds = (baseSeconds / brewSpeed).round();
  return Duration(seconds: adjustedSeconds);
}


int calculatePotionReward(List<int> ids) {
  int totalCost = 0;
  for (var id in ids) {
    totalCost += plants[id].cost;
  }

  // Determine multiplier based on recipe rarity
  final rarity = getRarity(ids);
  double multiplier = 1.5; // Common: 50% profit
  if (rarity == Rarity.rare) multiplier = 2.5; // Rare: 150% profit
  if (rarity == Rarity.epic) multiplier = 5.0; // Legendary: 400% profit

  double reward = totalCost * multiplier;

  // First Discovery Bonus: Double the gold!
  ids.sort();
  String key = ids.join("_");
  if (!discovered.contains(key)) {
    reward *= 2;
  }

  return reward.round();
}


int nextGardenSlotCost() {
  if (unlockedSlots >= maxGardenSlots) return -1;

  // Exponential scaling: 500, 2500, 12500, 62500...
  // This ensures players can't buy all slots in the first week.
  switch (unlockedSlots) {
    case 3: return 500;
    case 4: return 2500;
    case 5: return 10000;
    case 6: return 25000;
    case 7: return 75000;
    case 8: return 200000;
    case 9: return 500000;
    default: return 1000000;
  }
}












final List<Plant> plants = [
  // COMMON (0–2)
  Plant(0, "Sunleaf", 2, Duration(seconds: 10)),
  Plant(1, "Moonpetal", 3, Duration(seconds: 15)),
  Plant(2, "Starroot", 4, Duration(seconds: 20)),

  // RARE (3–5)
  Plant(3, "Frost Fern", 8, Duration(minutes: 1)),
  Plant(4, "Mint Crystal", 10, Duration(minutes: 2)),
  Plant(5, "Ember Blossom", 12, Duration(minutes: 3)),

  // LEGENDARY (6)
  Plant(6, "Phoenix Herb", 25, Duration(minutes: 6)),
];


void sellPotion(int slot) {
  final data = brewSlots[slot];
  if (data == null) return;

  List<int> ids = List<int>.from(data["plants"]);
  int reward = calculatePotionReward(ids);

  if (doubleGoldCharges > 0) {
    reward *= 2;
    doubleGoldCharges--;
  }

  ids.sort();
  String key = ids.join("_");
  checkDailyQuests(key);

  gold += reward;
  lastGoldGain = reward;
  showGoldAnimation = true;

  brewSlots[slot] = null;
  save();
  notifyListeners();

  Future.delayed(const Duration(milliseconds: 800), () {
    showGoldAnimation = false;
    notifyListeners();
  });
}



void checkDailyQuests(String key) {
  for (var q in dailyQuests) {
    if (!q.done && q.recipeKey == key) {
      q.done = true;
      gold += q.reward;
    }
  }

  if (dailyQuests.isNotEmpty &&
      dailyQuests.every((q) => q.done)) {
    giveDailyChest();
  }
}




void giveDailyChest() {
  final r = Random().nextDouble();

  if (r < 0.5) {
    storage[3] += 2;
  } else if (r < 0.8) {
    instantBrewTokens++;
  } else if (r < 0.95) {
    storage[6] += 1;
  } else {
    doubleGoldCharges += 3;
  }
}

void checkBrew() {


unlockedSlots = prefs.getInt("unlockedSlots") ?? 3;

lastQuestDay = prefs.getString("lastQuestDay") ?? "";


await prefs.setString("lastQuestDay", lastQuestDay);










void useInstantBrew(int slot) {
  final data = brewSlots[slot];
  if (data == null) return;
  if (instantBrewTokens <= 0) return;

  data["done"] = true;
  instantBrewTokens--;

  save();
  notifyListeners();
}


int doubleGoldCharges = 0;


void sellPotion(int slot) {
  final data = brewSlots[slot];
  if (data == null) return;

  List<int> ids = List<int>.from(data["plants"]);
  int reward = calculatePotionReward(ids);

  if (doubleGoldCharges > 0) {
    reward *= 2;
    doubleGoldCharges--;
  }

  gold += reward;
  lastGoldGain = reward;
  showGoldAnimation = true;

  brewSlots[slot] = null;
  save();
  notifyListeners();

  Future.delayed(const Duration(milliseconds: 800), () {
    showGoldAnimation = false;
    notifyListeners();
  });
}



class DailyQuest {
  String recipeKey;
  int reward;
  bool done;

  DailyQuest({
    required this.recipeKey,
    required this.reward,
    this.done = false,
  });
}


List<DailyQuest> dailyQuests = [];
String lastQuestDay = "";



void generateDailyQuestsIfNeeded() {
  String today = DateTime.now().toIso8601String().substring(0, 10);

  if (lastQuestDay == today) return;

  lastQuestDay = today;
  dailyQuests.clear();

  // 2 common + 1 rare
  final common = ["0_0_0", "1_1_1", "2_2_2"];
  final rare = ["3_3_3", "4_4_4", "5_5_5"];

  common.shuffle();
  rare.shuffle();

  dailyQuests.add(DailyQuest(
    recipeKey: common[0],
    reward: 10,
  ));
  dailyQuests.add(DailyQuest(
    recipeKey: common[1],
    reward: 12,
  ));
  dailyQuests.add(DailyQuest(
    recipeKey: rare[0],
    reward: 30,
  ));
}



void checkDailyQuests(String key) {
  for (var q in dailyQuests) {
    if (!q.done && q.recipeKey == key) {
      q.done = true;
      gold += q.reward;
    }
  }

  // ha mind kész → chest
  if (dailyQuests.every((q) => q.done)) {
    giveDailyChest();
  }
}



void giveDailyChest() {
  final r = Random().nextDouble();

  if (r < 0.5) {
    storage[3] += 2; // rare plant példa
  } else if (r < 0.8) {
    instantBrewTokens++;
  } else if (r < 0.95) {
    storage[6] += 1; // legendary plant
  } else {
    doubleGoldCharges += 3;
  }
}






class Recipe {
  final List<int> ids;
  final String name;
  final Rarity rarity;

  const Recipe(this.ids, this.name, this.rarity);

  String get key {
    final sorted = List<int>.from(ids)..sort();
    return sorted.join("_");
  }
}




const List<Recipe> allRecipes = [
  // COMMON
  Recipe([0, 0, 0], "Solar Tonic", Rarity.common),
  Recipe([1, 1, 1], "Lunar Draught", Rarity.common),
  Recipe([2, 2, 2], "Stellar Essence", Rarity.common),
  Recipe([0, 1, 2], "Balanced Brew", Rarity.common),
  Recipe([0, 0, 1], "Dawn Mixture", Rarity.common),

  // RARE
  Recipe([0, 0, 3], "Glow Tonic", Rarity.rare),
  Recipe([1, 1, 4], "Moonmint Infusion", Rarity.rare),
  Recipe([2, 2, 5], "Ember Essence", Rarity.rare),
  Recipe([3, 3, 3], "Fern Extract", Rarity.rare),
  Recipe([4, 4, 4], "Mint Concentrate", Rarity.rare),
  Recipe([5, 5, 5], "Ember Core", Rarity.rare),
  Recipe([3, 4, 5], "Elemental Mix", Rarity.rare),

  // LEGENDARY
  Recipe([6, 6, 6], "Elixir of Rebirth", Rarity.epic),
  Recipe([5, 6, 6], "Phoenix Blood", Rarity.epic),
  Recipe([4, 6, 6], "Celestial Flame", Rarity.epic),
];




String getPotionName(List<int> ids) {
  final sorted = List<int>.from(ids)..sort();
  final key = sorted.join("_");

  for (final recipe in allRecipes) {
    if (recipe.key == key) {
      return recipe.name;
    }
  }

  return "Mystic Elixir";
}






Rarity getRarity(List<int> ids) {
  final sorted = List<int>.from(ids)..sort();
  final key = sorted.join("_");

  for (final recipe in allRecipes) {
    if (recipe.key == key) {
      return recipe.rarity;
    }
  }

  return Rarity.common;
}



@override
Widget build(BuildContext context) {
  return Scaffold(
    appBar: AppBar(title: const Text("Potion Book")),
    body: ListView(
      children: allRecipes.map((recipe) {
        final discovered = game.discovered.contains(recipe.key);

        return Card(
          margin: const EdgeInsets.symmetric(
              horizontal: 12, vertical: 6),
          child: ListTile(
            leading: Icon(
              Icons.local_drink,
              color: discovered
                  ? game.rarityColor(recipe.rarity)
                  : Colors.grey,
              size: 32,
            ),
            title: Text(
              discovered ? recipe.name : "????",
              style: const TextStyle(
                fontWeight: FontWeight.bold,
              ),
            ),
            subtitle: Text(
              discovered
                  ? "Recipe: ${recipe.ids.join(" + ")}"
                  : "Recipe: ???",
            ),
          ),
        );
      }).toList(),
    ),
  );
}















final List<Plant> plants = [
  // COMMON (0–2)
  Plant("Sunleaf", 5, Colors.green),
  Plant("Moonpetal", 6, Colors.lightBlue),
  Plant("Starroot", 7, Colors.yellow),

  // RARE (3–5)
  Plant("Frost Fern", 15, Colors.cyan),
  Plant("Mint Crystal", 18, Colors.teal),
  Plant("Ember Blossom", 22, Colors.deepOrange),

  // LEGENDARY (6)
  Plant("Phoenix Herb", 100, Colors.redAccent),
];




String getPotionName(List<int> ids) {
  ids = List.from(ids)..sort();
  final key = ids.join("_");

  const names = {
    // COMMON – only plants 0–2
    "0_0_0": "Solar Tonic",
    "1_1_1": "Lunar Draught",
    "2_2_2": "Stellar Essence",
    "0_1_2": "Balanced Brew",
    "0_0_1": "Dawn Mixture",

    // RARE – plants 3–5 involved
    "0_0_3": "Glow Tonic",
    "1_1_4": "Moonmint Infusion",
    "2_2_5": "Ember Essence",
    "0_3_4": "Crystal Blend",
    "1_4_5": "Frost Ember Draught",
    "2_3_5": "Flare Potion",
    "3_3_3": "Fern Extract",
    "4_4_4": "Mint Concentrate",
    "5_5_5": "Ember Core",
    "3_4_5": "Elemental Mix",

    // LEGENDARY – phoenix plant
    "6_6_6": "Elixir of Rebirth",
    "5_6_6": "Phoenix Blood",
    "4_6_6": "Celestial Flame",
  };

  return names[key] ?? "Mystic Elixir";
}





Rarity getRarity(List<int> ids) {
  ids = List.from(ids)..sort();
  final key = ids.join("_");

  const commonRecipes = {
    "0_0_0",
    "1_1_1",
    "2_2_2",
    "0_1_2",
    "0_0_1",
  };

  const rareRecipes = {
    "0_0_3",
    "1_1_4",
    "2_2_5",
    "0_3_4",
    "1_4_5",
    "2_3_5",
    "3_3_3",
    "4_4_4",
    "5_5_5",
    "3_4_5",
  };

  const legendaryRecipes = {
    "6_6_6",
    "5_6_6",
    "4_6_6",
  };

  if (legendaryRecipes.contains(key)) {
    return Rarity.epic;
  }
  if (rareRecipes.contains(key)) {
    return Rarity.rare;
  }
  if (commonRecipes.contains(key)) {
    return Rarity.common;
  }

  return Rarity.common;
}







String getPotionName(List<int> ids) {
  ids = List.from(ids)..sort();
  final key = ids.join("_");

  const names = {
    // COMMON – free plants only (5 recipes)
    "0_0_0": "Solar Tonic",
    "1_1_1": "Lunar Draught",
    "2_2_2": "Stellar Essence",
    "0_1_2": "Balanced Brew",
    "0_0_1": "Dawn Mixture",

    // RARE – at least one paid plant (10 recipes)
    "0_0_3": "Glow Tonic",
    "1_1_3": "Moonlit Infusion",
    "2_2_4": "Frost Essence",
    "0_3_4": "Crystal Blend",
    "1_4_5": "Ember Draught",
    "2_3_5": "Flare Potion",
    "3_3_3": "Fern Extract",
    "4_4_4": "Mint Concentrate",
    "5_5_5": "Ember Core",
    "3_4_5": "Elemental Mix",

    // LEGENDARY – very expensive
    "9_9_9": "Elixir of Rebirth",
    "8_9_9": "Phoenix Blood",
    "7_9_9": "Celestial Flame",
  };

  return names[key] ?? "Mystic Elixir";
}




Rarity getRarity(List<int> ids) {
  ids = List.from(ids)..sort();
  final key = ids.join("_");

  const commonRecipes = {
    "0_0_0",
    "1_1_1",
    "2_2_2",
    "0_1_2",
    "0_0_1",
  };

  const rareRecipes = {
    "0_0_3",
    "1_1_3",
    "2_2_4",
    "0_3_4",
    "1_4_5",
    "2_3_5",
    "3_3_3",
    "4_4_4",
    "5_5_5",
    "3_4_5",
  };

  const legendaryRecipes = {
    "9_9_9",
    "8_9_9",
    "7_9_9",
  };

  if (legendaryRecipes.contains(key)) {
    return Rarity.epic;
  }
  if (rareRecipes.contains(key)) {
    return Rarity.rare;
  }
  if (commonRecipes.contains(key)) {
    return Rarity.common;
  }

  return Rarity.common;
}








children: List.generate(game.garden.length, (i) {
        if (i >= game.unlockedSlots) {
          int cost = game.nextGardenSlotCost();
      
          return SizedBox(
            width: 100,
            height: 100,
            child: ElevatedButton(
              onPressed: game.gold >= cost
                  ? game.unlockGardenSlot
                  : null,
              child: Text(
                cost < 0
                    ? "MAX"
                    : "Unlock\n${cost}g",
                textAlign: TextAlign.center,
              ),
            ),
          );
        }
      
        final slot = game.garden[i];
      
        if (slot == null) {
          return SizedBox(
            width: 100,
            height: 100,
            child: ElevatedButton(
              onPressed: () {
                showDialog(
                  context: context,
                  builder: (_) => plantDialog(context, i),
                );
              },
              child: const Text("Plant"),
            ),
          );
        } else {
          int id = slot["plant"];
          int start = slot["start"];
          final p = plants[id];
      
          final elapsed = DateTime.now().difference(
              DateTime.fromMillisecondsSinceEpoch(start));
      
          double progress =
              elapsed.inMilliseconds /
                  p.growTime.inMilliseconds;
      
          if (progress >= 1) {
            return SizedBox(
              width: 100,
              height: 100,
              child: ElevatedButton(
                onPressed: () => game.harvest(i),
                child: Text("Harvest\n${p.name}",
                    textAlign: TextAlign.center),
              ),
            );
          }
      
          return SizedBox(
            width: 100,
            height: 100,
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Text(p.name, textAlign: TextAlign.center),
                const SizedBox(height: 6),
                LinearProgressIndicator(value: progress),
              ],
            ),
          );
        }
      }),








return Wrap(
    spacing: 10,
      runSpacing: 10,
        children: ...
        );
)
