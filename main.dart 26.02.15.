import 'dart:math';
import 'dart:async';
import 'dart:convert';
import 'package:flutter/material.dart';
import 'package:shared_preferences/shared_preferences.dart';

void main() {
  runApp(const MyApp());
}

class Plant {
  final int id;
  final String name;
  final int cost;
  final Duration growTime;

  const Plant(this.id, this.name, this.cost, this.growTime);
}

final List<Plant> plants = [
  // COMMON (Active Play: 1m to 15m)
  Plant(0, "Sunleaf", 5, Duration(minutes: 1)),
  Plant(1, "Moonpetal", 20, Duration(minutes: 5)),
  Plant(2, "Starroot", 50, Duration(minutes: 15)),

  // RARE (Occasional Check-ins: 1h to 8h)
  Plant(3, "Frost Fern", 200, Duration(hours: 1)),
  Plant(4, "Mint Crystal", 750, Duration(hours: 4)),
  Plant(5, "Ember Blossom", 2000, Duration(hours: 8)),

  // LEGENDARY (The Daily Hook: 24h)
  Plant(6, "Phoenix Herb", 10000, Duration(hours: 24)),
];

class Recipe {
  final List<int> ids;
  final String name;
  final Rarity rarity;

  const Recipe(this.ids, this.name, this.rarity);

  String get key {
    final sorted = List<int>.from(ids)..sort();
    return sorted.join("_");
  }
}
const List<Recipe> allRecipes = [
  // COMMON
  Recipe([0, 0, 0], "Solar Tonic", Rarity.common),
  Recipe([1, 1, 1], "Lunar Draught", Rarity.common),
  Recipe([2, 2, 2], "Stellar Essence", Rarity.common),
  Recipe([0, 1, 2], "Balanced Brew", Rarity.common),
  Recipe([0, 0, 1], "Dawn Mixture", Rarity.common),

  // RARE
  Recipe([0, 0, 3], "Glow Tonic", Rarity.rare),
  Recipe([1, 1, 4], "Moonmint Infusion", Rarity.rare),
  Recipe([2, 2, 5], "Ember Essence", Rarity.rare),
  Recipe([3, 3, 3], "Fern Extract", Rarity.rare),
  Recipe([4, 4, 4], "Mint Concentrate", Rarity.rare),
  Recipe([5, 5, 5], "Ember Core", Rarity.rare),
  Recipe([3, 4, 5], "Elemental Mix", Rarity.rare),

  // LEGENDARY
  Recipe([6, 6, 6], "Elixir of Rebirth", Rarity.epic),
  Recipe([5, 6, 6], "Phoenix Blood", Rarity.epic),
  Recipe([4, 6, 6], "Celestial Flame", Rarity.epic),
];

String getPotionName(List<int> ids) {
  final sorted = List<int>.from(ids)..sort();
  final key = sorted.join("_");

  for (final recipe in allRecipes) {
    if (recipe.key == key) {
      return recipe.name;
    }
  }

  return "Mystic Elixir";
}


String formatTime(int seconds) {
  if (seconds <= 0) return "Ready";

  if (seconds < 60) {
    return "$seconds sec";
  }

  int minutes = (seconds / 60).ceil();

  if (minutes < 60) {
    return "$minutes min";
  }

  int hours = (minutes / 60).ceil();
  return "$hours h";
}


enum Rarity { common, rare, epic }

class DailyQuest {
  String recipeKey;
  int reward;
  bool done;

  DailyQuest({
    required this.recipeKey,
    required this.reward,
    this.done = false,
  });

  Map<String, dynamic> toJson() {
    return {
      "key": recipeKey,
      "reward": reward,
      "done": done,
    };
  }

  factory DailyQuest.fromJson(Map<String, dynamic> json) {
    return DailyQuest(
      recipeKey: json["key"],
      reward: json["reward"],
      done: json["done"],
    );
  }
}

class GameState extends ChangeNotifier {
  int gold = 0;
  int speedLevel = 0;
  int instantBrewTokens = 0;
  int doubleGoldCharges = 0;
  double brewSpeed = 1.0;
  int unlockedSlots = 3;
  int lastGoldGain = 0;
  bool showGoldAnimation = false;
  List<DailyQuest> dailyQuests = [];
  String lastQuestDay = "";

  int checkDailyQuests(String key) {
    int reward = 0;
  
    for (var q in dailyQuests) {
      if (!q.done && q.recipeKey == key) {
        q.done = true;
        reward += q.reward;
      }
    }
  
    if (dailyQuests.isNotEmpty &&
        dailyQuests.every((q) => q.done)) {
      giveDailyChest();
    }
  
    return reward;
  }

  void generateDailyQuestsIfNeeded() {
    String today = DateTime.now().toIso8601String().substring(0, 10);
  
    if (lastQuestDay == today && dailyQuests.isNotEmpty) {
      return; // már vannak questek mára
    }
  
    lastQuestDay = today;
    dailyQuests.clear();
  
    final common = ["0_0_0", "1_1_1", "2_2_2"];
    final rare = ["3_3_3", "4_4_4", "5_5_5"];
  
    common.shuffle();
    rare.shuffle();
  
    dailyQuests.add(DailyQuest(
      recipeKey: common[0],
      reward: 10,
    ));
    dailyQuests.add(DailyQuest(
      recipeKey: common[1],
      reward: 12,
    ));
    dailyQuests.add(DailyQuest(
      recipeKey: rare[0],
      reward: 30,
    ));
  
    save();
  }
  int speedUpgradeCost() {
    return 50 * (speedLevel + 1);
  }

  void upgradeSpeed() {
    int cost = speedUpgradeCost();
    if (gold < cost) return;

    gold -= cost;
    speedLevel++;
    brewSpeed = 1.0 + speedLevel * 0.25;

    save();
    notifyListeners();
  }

void useInstantBrew(int slot) {
  final data = brewSlots[slot];
  if (data == null) return;
  if (instantBrewTokens <= 0) return;

  data["done"] = true;
  instantBrewTokens--;

  save();
  notifyListeners();
}


  void sellPotion(int slot) {
    final data = brewSlots[slot];
    if (data == null) return;
  
    List<int> ids = List<int>.from(data["plants"]);
    int reward = calculatePotionReward(ids);
  
    if (doubleGoldCharges > 0) {
      reward *= 2;
      doubleGoldCharges--;
    }
  
    ids.sort();
    String key = ids.join("_");
  
    int questReward = checkDailyQuests(key);
    int total = reward + questReward;
  
    gold += total;
    lastGoldGain = total;
    showGoldAnimation = true;
  
    brewSlots[slot] = null;
    save();
    notifyListeners();
  
    Future.delayed(const Duration(milliseconds: 800), () {
      showGoldAnimation = false;
      notifyListeners();
    });
  }

  static const int maxGardenSlots = 10;

  List<Map<String, dynamic>?> garden =
  List.generate(maxGardenSlots, (_) => null);

  List<int> storage =
  List.generate(10, (_) => 0);

  List<Map<String, dynamic>?> brewSlots =
  List.generate(3, (_) => null);

  Set<String> discovered = {};

  late SharedPreferences prefs;

  int nextGardenSlotCost() {
    if (unlockedSlots >= maxGardenSlots) return -1;
  
    switch (unlockedSlots) {
      case 3: return 500;
      case 4: return 2500;
      case 5: return 10000;
      case 6: return 25000;
      case 7: return 75000;
      case 8: return 200000;
      case 9: return 500000;
      default: return 1000000;
    }
  }

  void unlockGardenSlot() {
    int cost = nextGardenSlotCost();
    if (cost < 0) return;
    if (gold < cost) return;

    gold -= cost;
    unlockedSlots++;

    save();
    notifyListeners();
  }

  Future<void> load() async {
    prefs = await SharedPreferences.getInstance();
    gold = prefs.getInt("gold") ?? 0;
    unlockedSlots = prefs.getInt("unlockedSlots") ?? 3;
    speedLevel = prefs.getInt("speedLevel") ?? 0;
    brewSpeed = 1.0 + speedLevel * 0.25;

    storage =
        List.generate(10, (i) => prefs.getInt("storage_$i") ?? 0);

    for (int i = 0; i < maxGardenSlots; i++) {
      String? data = prefs.getString("garden_$i");
      if (data != null) {
        garden[i] = jsonDecode(data);
      }
    }

    for (int i = 0; i < 3; i++) {
      String? data = prefs.getString("brew_$i");
      if (data != null) {
        brewSlots[i] = jsonDecode(data);
      }
    }

    discovered =
        prefs.getStringList("recipes")?.toSet() ?? {};

    lastQuestDay = prefs.getString("lastQuestDay") ?? "";
    
    // daily questek betöltése
    List<String>? questJson = prefs.getStringList("dailyQuests");
    if (questJson != null) {
      dailyQuests = questJson
          .map((q) => DailyQuest.fromJson(jsonDecode(q)))
          .toList();
    }
    notifyListeners();

  }

  Future<void> save() async {
    await prefs.setInt("unlockedSlots", unlockedSlots);
    await prefs.setInt("speedLevel", speedLevel);

    for (int i = 0; i < 10; i++) {
      await prefs.setInt("storage_$i", storage[i]);
    }

    for (int i = 0; i < maxGardenSlots; i++) {
      if (garden[i] != null) {
        await prefs.setString(
            "garden_$i", jsonEncode(garden[i]));
      } else {
        await prefs.remove("garden_$i");
      }
    }

    for (int i = 0; i < 3; i++) {
      if (brewSlots[i] != null) {
        await prefs.setString(
            "brew_$i", jsonEncode(brewSlots[i]));
      } else {
        await prefs.remove("brew_$i");
      }
    }

    await prefs.setStringList(
        "recipes", discovered.toList());
    await prefs.setString("lastQuestDay", lastQuestDay);

    List<String> questJson = dailyQuests
        .map((q) => jsonEncode(q.toJson()))
        .toList();
    
    await prefs.setStringList("dailyQuests", questJson);
  }

  void plant(int slot, int plantId) {
    final p = plants[plantId];
    if (p.cost > gold) return;

    gold -= p.cost;

    garden[slot] = {
      "plant": plantId,
      "start": DateTime
          .now()
          .millisecondsSinceEpoch
    };

    save();
    notifyListeners();
  }

  void harvest(int slot) {
    final data = garden[slot];
    if (data == null) return;

    int plantId = data["plant"];
    int start = data["start"];

    final p = plants[plantId];
    final elapsed = DateTime.now().difference(
        DateTime.fromMillisecondsSinceEpoch(start));

    if (elapsed >= p.growTime) {
      storage[plantId]++;
      garden[slot] = null;
      save();
      notifyListeners();
    }
  }

  Rarity getRarity(List<int> ids) {
    final sorted = List<int>.from(ids)..sort();
    final key = sorted.join("_");
  
    for (final recipe in allRecipes) {
      if (recipe.key == key) {
        return recipe.rarity;
      }
    }
  
    return Rarity.common;
  }

  Color rarityColor(Rarity r) {
    switch (r) {
      case Rarity.common:
        return Colors.grey;
      case Rarity.rare:
        return Colors.blue;
      case Rarity.epic:
        return Colors.purple;
    }
  }

  Duration brewTime(List<int> ids) {
    int totalGrowSeconds = 0;
    for (var id in ids) {
      totalGrowSeconds += plants[id].growTime.inSeconds;
    }
  
    double baseSeconds = totalGrowSeconds * 0.5;
    
    if (baseSeconds < 30) baseSeconds = 30;
  
    int adjustedSeconds = (baseSeconds / brewSpeed).round();
    return Duration(seconds: adjustedSeconds);
  }

  void startBrew(int slot, List<int> ids) {
    for (var id in ids) {
      if (storage[id] <= 0) return;
    }

    for (var id in ids) {
      storage[id]--;
    }

    final time = brewTime(ids);

    brewSlots[slot] = {
      "plants": ids,
      "start": DateTime
          .now()
          .millisecondsSinceEpoch,
      "time": time.inSeconds,
      "done": false
    };

    save();
    notifyListeners();
  }

  int calculatePotionReward(List<int> ids) {
    int totalCost = 0;
    for (var id in ids) {
      totalCost += plants[id].cost;
    }
  
    final rarity = getRarity(ids);
    double multiplier = 1.5; // Common: 50% profit
    if (rarity == Rarity.rare) multiplier = 2.5; // Rare: 150% profit
    if (rarity == Rarity.epic) multiplier = 5.0; // Legendary: 400% profit
  
    double reward = totalCost * multiplier;
  
    ids.sort();
    String key = ids.join("_");
    if (!discovered.contains(key)) {
      reward *= 2;
    }
  
    return reward.round();
  }


    void giveDailyChest() {
      final r = Random().nextDouble();
    
      if (r < 0.5) {
        storage[3] += 2; // rare plant példa
      } else if (r < 0.8) {
        instantBrewTokens++;
      } else if (r < 0.95) {
        storage[6] += 1; // legendary plant
      } else {
        doubleGoldCharges += 3;
      }
    }
  
  void checkBrew() {
    for (int i = 0; i < 3; i++) {
      final slot = brewSlots[i];
      if (slot == null) continue;

      if (slot["done"] == true) continue;

      int start = slot["start"];
      int total = slot["time"];

      int elapsed = DateTime
          .now()
          .difference(
          DateTime.fromMillisecondsSinceEpoch(start))
          .inSeconds;

      if (elapsed >= total) {
        List<int> ids =
        List<int>.from(slot["plants"]);
        ids.sort();
        discovered.add(ids.join("_"));
        slot["done"] = true;
      }
    }

    save();
    notifyListeners();
  }
}

class MyApp extends StatefulWidget {
  const MyApp({super.key});

  @override
  State<MyApp> createState() => _MyAppState();
}

class _MyAppState extends State<MyApp> {
  final game = GameState();
  bool loaded = false;
  int screen = 0;

  @override
  void initState() {
    super.initState();
    game.load().then((_) {
      setState(() {
        loaded = true;
      });
      Timer.periodic(
          const Duration(seconds: 1), (_) => game.checkBrew());
    });
  }

  @override
  Widget build(BuildContext context) {
    if (!loaded) {
      return const MaterialApp(
          home: Scaffold(
              body: Center(child: CircularProgressIndicator())));
    }

    return MaterialApp(
        home: Builder(
          builder: (context) =>
              AnimatedBuilder(
                animation: game,
                builder: (_, __) =>
                    Stack(
                      children: [
                        Scaffold(
                          appBar: AppBar(
                            title: Text("Gold: ${game.gold}"),
                            actions: [
                              TextButton(
                                onPressed: () => setState(() => screen = 0),
                                child: const Text("Shop", style: TextStyle(color: Colors.white)),
                              ),
                              TextButton(
                                onPressed: () => setState(() => screen = 1),
                                child: const Text("Garden", style: TextStyle(color: Colors.white)),
                              ),
                              IconButton(
                                icon: const Icon(Icons.book),
                                onPressed: () {
                                  Navigator.push(
                                    context,
                                    MaterialPageRoute(
                                      builder: (_) => RecipeBookScreen(game),
                                    ),
                                  );
                                },
                              ),
                            ],
                          ),
                          body: screen == 0
                              ? PotionScreen(game)
                              : GardenScreen(game),
                        ),

                        if (game.showGoldAnimation)
                          Positioned(
                            top: 60,
                            left: 20,
                            child: TweenAnimationBuilder(
                              tween: Tween<double>(begin: 0, end: -40),
                              duration: const Duration(milliseconds: 800),
                              builder: (_, double value, child) {
                                return Transform.translate(
                                  offset: Offset(0, value),
                                  child: Opacity(
                                    opacity: 1 - (value.abs() / 40),
                                    child: child,
                                  ),
                                );
                              },
                              child: Row(
                                children: [
                                  const Icon(Icons.monetization_on,
                                      color: Colors.amber, size: 24),
                                  Text(
                                    "+${game.lastGoldGain}",
                                    style: const TextStyle(
                                        color: Colors.amber,
                                        fontWeight: FontWeight.bold,
                                        fontSize: 18),
                                  ),
                                ],
                              ),
                            ),
                          ),
                      ],
                    ),
              ),
        ),
        );
    }
}

class PotionScreen extends StatelessWidget {
  final GameState game;

  const PotionScreen(this.game, {super.key});

  @override
  Widget build(BuildContext context) {
    return Row(
      children: [
        Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Text("Speed Lv. ${game.speedLevel}"),
            ElevatedButton(
              onPressed: game.gold >= game.speedUpgradeCost()
                  ? game.upgradeSpeed
                  : null,
              child: Text(
                "Upgrade (${game.speedUpgradeCost()}g)",
              ),
            ),
            const SizedBox(height: 10),
          ],
        ),
        Expanded(
          flex: 2,
          child: Row(
            mainAxisAlignment: MainAxisAlignment.spaceEvenly,
            children: List.generate(3, (i) {
              if (i >= game.unlockedSlots) {
                return ElevatedButton(
                  onPressed: game.gold >= game.nextGardenSlotCost()
                      ? () => game.unlockGardenSlot()
                      : null,
                  child: Text(
                    "Unlock\n${game.nextGardenSlotCost()}g",
                    textAlign: TextAlign.center,
                  ),
                );
              }

              final slot = game.brewSlots[i];


              if (slot == null) {
                return ElevatedButton(
                  onPressed: () {
                    showDialog(
                      context: context,
                      builder: (_) => brewDialog(context, i),
                    );
                  },
                  child: const Text("Brew"),
                );
              } else {
                int start = slot["start"];
                int total = slot["time"];
                bool done = slot["done"] == true;

                int elapsed = DateTime
                    .now()
                    .difference(
                    DateTime.fromMillisecondsSinceEpoch(start))
                    .inSeconds;

                double progress =
                (elapsed / total).clamp(0.0, 1.0);

                List<int> ids =
                List<int>.from(slot["plants"]);
                String name = getPotionName(ids);
                final rarity = game.getRarity(ids);

                return SizedBox(
                  width: 140,
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      AnimatedScale(
                        scale: done ? 1.2 : 1.0,
                        duration: const Duration(milliseconds: 400),
                        child: Icon(
                          Icons.local_drink,
                          size: 80,
                          color: done
                              ? game.rarityColor(rarity)
                              : Colors.grey,
                        ),
                      ),
                      const SizedBox(height: 8),
                      if (!done) ...[
                        LinearProgressIndicator(value: progress),
                        const SizedBox(height: 6),
                        Builder(
                          builder: (_) {
                            int remaining = (total - elapsed).clamp(0, total);
                            return Text(formatTime(remaining));
                          },
                        ),
                      ] else
                        ...[
                          const SizedBox(height: 6),
                          Text(
                            name,
                            textAlign: TextAlign.center,
                            style: const TextStyle(
                              fontWeight: FontWeight.bold,
                            ),
                          ),
                          const SizedBox(height: 6),
                          ElevatedButton(
                            onPressed: () => game.sellPotion(i),
                            child: Text(
                              "SELL for ${game.calculatePotionReward(ids)}g",
                            ),
                          ),
                        ],
                    ],
                  ),
                );
              }
            }),
          ),
        ),
        Expanded(
          child: InventoryPanel(game),
        )
      ],
    );
  }

  Widget brewDialog(BuildContext context, int slot) {
    List<int> selected = [];

    return StatefulBuilder(
      builder: (context, setState) {
        return AlertDialog(
          title: const Text("Select 3 plants"),
          content: SizedBox(
            width: 300,
            height: 300,
            child: ListView(
              children: plants.map((p) {
                return ListTile(
                  title: Text(
                      "${p.name} (${game.storage[p.id]})"),
                  onTap: () {
                    if (game.storage[p.id] > 0 &&
                        selected.length < 3) {
                      selected.add(p.id);
                      setState(() {});
                    }
                  },
                );
              }).toList(),
            ),
          ),
          actions: [
            Text("Selected: ${selected.length}/3"),
            ElevatedButton(
              onPressed: selected.length == 3
                  ? () {
                game.startBrew(slot, selected);
                Navigator.pop(context);
              }
                  : null,
              child: const Text("BREW"),
            )
          ],
        );
      },
    );
  }
}


class InventoryPanel extends StatelessWidget {
  final GameState game;

  const InventoryPanel(this.game, {super.key});

  @override
  Widget build(BuildContext context) {
    return Card(
      margin: const EdgeInsets.all(12),
      child: ListView(
        children: [
          const Padding(
            padding: EdgeInsets.all(8),
            child: Text("Inventory",
                style: TextStyle(
                    fontSize: 18,
                    fontWeight: FontWeight.bold)),
          ),
          ...plants.map((p) {
            return ListTile(
              title: Text(p.name),
              trailing: Text("${game.storage[p.id]}"),
            );
          })
        ],
      ),
    );
  }
}

class GardenScreen extends StatelessWidget {
  final GameState game;

  const GardenScreen(this.game, {super.key});

  @override
  Widget build(BuildContext context) {
    return Wrap(
      spacing: 10,
      runSpacing: 10,
      children: List.generate(game.garden.length, (i) {
        if (i >= game.unlockedSlots) {
          int cost = game.nextGardenSlotCost();
      
          return SizedBox(
            width: 100,
            height: 100,
            child: ElevatedButton(
              onPressed: game.gold >= cost
                  ? game.unlockGardenSlot
                  : null,
              child: Text(
                cost < 0
                    ? "MAX"
                    : "Unlock\n${cost}g",
                textAlign: TextAlign.center,
              ),
            ),
          );
        }
      
        final slot = game.garden[i];
      
        if (slot == null) {
          return SizedBox(
            width: 100,
            height: 100,
            child: ElevatedButton(
              onPressed: () {
                showDialog(
                  context: context,
                  builder: (_) => plantDialog(context, i),
                );
              },
              child: const Text("Plant"),
            ),
          );
        } else {
          int id = slot["plant"];
          int start = slot["start"];
          final p = plants[id];
      
          final elapsed = DateTime.now().difference(
              DateTime.fromMillisecondsSinceEpoch(start));
      
          double progress =
              elapsed.inMilliseconds /
                  p.growTime.inMilliseconds;
      
          if (progress >= 1) {
            return SizedBox(
              width: 100,
              height: 100,
              child: ElevatedButton(
                onPressed: () => game.harvest(i),
                child: Text("Harvest\n${p.name}",
                    textAlign: TextAlign.center),
              ),
            );
          }
      
          return SizedBox(
            width: 100,
            height: 100,
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Text(p.name, textAlign: TextAlign.center),
                const SizedBox(height: 6),
                LinearProgressIndicator(value: progress),
              ],
            ),
          );
        }
      }),
    );
  }

  Widget plantDialog(BuildContext context, int slot) {
    return AlertDialog(
      title: const Text("Choose plant"),
      content: SizedBox(
        width: 300,
        height: 300,
        child: GridView.count(
          crossAxisCount: 2,
          children: plants.map((p) {
            return ElevatedButton(
              onPressed: () {
                game.plant(slot, p.id);
                Navigator.pop(context);
              },
              child: Text("${p.name}\n${p.cost}g"),
            );
          }).toList(),
        ),
      ),
    );
  }
}

class RecipeBookScreen extends StatelessWidget {
  final GameState game;

  const RecipeBookScreen(this.game, {super.key});

  List<List<int>> _parseRecipes(Set<String> discovered) {
    return discovered.map((key) {
      return key.split("_").map(int.parse).toList();
    }).toList();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text("Potion Book")),
      body: ListView(
        children: allRecipes.map((recipe) {
          final discovered = game.discovered.contains(recipe.key);
  
          return Card(
            margin: const EdgeInsets.symmetric(
                horizontal: 12, vertical: 6),
            child: ListTile(
              leading: Icon(
                Icons.local_drink,
                color: discovered
                    ? game.rarityColor(recipe.rarity)
                    : Colors.grey,
                size: 32,
              ),
              title: Text(
                discovered ? recipe.name : "????",
                style: const TextStyle(
                  fontWeight: FontWeight.bold,
                ),
              ),
              subtitle: Text(
                discovered
                    ? "Recipe: ${recipe.ids.join(" + ")}"
                    : "Recipe: ???",
              ),
            ),
          );
        }).toList(),
      ),
    );
  }
}
